meme central:memescript/compiler

// requires io
// where
//   io         = central:stdlib/io

class Param
  fields: name, typeName, isPointer, isArray, isConst, isUnsigned,
    isOutput, isNullable;

  init new: fun() {
    @isPointer = false;
    @isArray = false;
    @isConst = false;
    @isUnsigned = false;
    @isOutput = false;
    @isNullable = false;
  }
  instance_method setName: fun(name) { @name = name; }
  instance_method setTypeName: fun(typeName) { @typeName = typeName; }
  instance_method setIsArray: fun(isArray) { @isArray = isArray; }
  instance_method setIsPointer: fun(isPointer) { @isPointer = isPointer; }
  instance_method setIsConst: fun(isConst) { @isConst = isConst; }
  instance_method setIsUnsigned: fun(isUnsigned) { @isUnsigned = isUnsigned; }
  instance_method setIsOutput: fun(isOutput) { @isOutput = isOutput; }
  instance_method setIsNullable: fun(isNullable) { @isNullable = isNullable; }
  instance_method setAnnotations: fun(annotations) {
    annotations.each(fun(_, a) {
      if (a == "out") {
        this.setIsOutput(true);
      } elif (a == "null") {
        this.setIsNullable(true);
      }
    });
  }

  instance_method getName: fun() { return @name; }
  instance_method getTypeName: fun() { return @typeName; }
  instance_method getIsArray: fun() { return @isArray; }
  instance_method getIsPointer: fun() { return @isPointer; }
  instance_method getIsConst: fun() { return @isConst; }
  instance_method getIsUnsigned: fun() { return @isUnsigned; }
  instance_method getIsOutput: fun() { return @isOutput; }
  instance_method getIsNullable: fun() { return @isNullable; }

  instance_method genType: fun() {
    var out = [];
    if (this.getIsConst()) { out.append("const"); }
    if (this.getIsUnsigned()) { out.append("unsigned"); }
    out.append(this.getTypeName());
    if (this.getIsPointer()) { out.append("*"); }
    return out.join(" ");
  }
  instance_method toString: fun() {
    return [
      "       Name: " + @name.toString,
      "   TypeName: " + @typeName.toString,
      "    IsArray: " + @isArray.toString,
      "    IsConst: " + @isConst.toString,
      "  IsPointer: " + @isPointer.toString,
      " IsUnsigned: " + @isUnsigned.toString,
      "   IsOutput: " + @isOutput.toString,
      " IsNullable: " + @isNullable.toString
    ].join("\n");
  }
end

class Struct
  fields: name, fieldList;

  init new: fun() {
    @fieldList = [];
  }
  instance_method newChild: fun() {
    var newField = Param.new();
    @fieldList.append(newField);
    return newField;
  }
  instance_method getName: fun() {
    return @name;
  }
  instance_method getFieldList: fun() {
    return @fieldList;
  }
  instance_method setName: fun(name) {
    @name = name;
  }
  instance_method toString: fun() {
    var structFields = @fieldList
      .map(fun(i) { return [" ", i.genType, i.getName].join(" ") + ";"; })
      .join("\n");
    return ["struct", @name, "{\n", structFields, "\n}"].join(" ");
  }
end

class Fun
  fields: name, params, rtype;

  init new: fun(name) {
    @name = name;
    @params = [];
  }
  instance_method newChild: fun() {
    var param = Param.new();
    @params.append(param);
    return param;
  }
  instance_method newReturnType: fun() {
    var rtype = Param.new();
    @rtype = rtype;
    return rtype;
  }
  instance_method getName: fun() {
    return @name;
  }
  instance_method getParams: fun() {
    return @params;
  }
  instance_method getReturnType: fun() {
    return @rtype;
  }
  instance_method genFunSignature: fun() {
    return ["static", "int", "prim_" + this.getName(),
            "(Process* proc)", "{"].join(" ");
  }
  instance_method genGetArg: fun(i, arg) {
    return ["  oop", "oop_" + arg.getName(), "=",
            "proc->get_arg(" + i.toString() + ");"].join(" ");
  }
  instance_method getTypeNameFromParam: fun(param) {
    var typeName = param.getTypeName();
    if (typeName.substr(0, 7) == "struct ") {
      return "struct";
    }
    return typeName;
  }
  instance_method genChkArg: fun(arg) {
    var out = [];
    var typeName = this.getTypeNameFromParam(arg);
    var primeType = {
      "int": "Integer",
      "char": "String",
      "struct": "Object"
    }[typeName];
    if (!primeType) {
      Exception.throw("Unknown type `" + typeName + "'");
    }

    var vname = "oop_" + arg.getName();
    var errMessage = "Argument `" + arg.getName() + "' expected " + primeType;
    var typeValidator =
      "!(proc->mmobj()->mm_object_vt(" + vname + ") == proc->vm()->get_prime(\"" + primeType + "\"))";
    var validation = typeValidator;
    if (arg.getIsNullable) {
      validation = "(" + vname + " != MM_NULL) && " + typeValidator;
      errMessage = errMessage + " or null";
    }

    out.append("  if (" + validation + ") {");
    out.append("    proc->raise(\"TypeError\", \"" + errMessage + "\");");
    out.append("  }");
    return out.join("\n");
  }
  instance_method genUnwrapArg: fun(arg) {
    var typeName = this.getTypeNameFromParam(arg);
    var type = arg.genType();
    var argName = "oop_" + arg.getName();
    var unwrap = {
      "int": "untag_small_int(" + argName + ")",
      "char": "proc->mmobj()->mm_string_cstr(proc, " + argName + "))",
      "struct": "(" + type + ") ((oop *) " + argName + ")[2]"
    }[typeName];
    if (!unwrap) {
      Exception.throw("Unknown type `" + typeName + "'");
    }
    if (arg.getIsNullable()) {
      unwrap = "(" + argName + " == MM_NULL ? NULL : " + unwrap + ")";
    }
    var out = [" "];            // indentation
    out.append(type);
    return (out + [arg.getName(), "=", unwrap + ";"]).join(" ");
  }
  instance_method genFunCall: fun() {
    var paramNames = this.getParams().map(fun(p) { p.getName });
    var params = "(" + paramNames.join(", ") + ");";
    var rtype = this.getReturnType();
    var out = [];
    if (rtype) {
      var typeName = rtype.getTypeName();
      var wrap = {
        "int": "tag_small_int(oop_output)",
        "char": "proc->mmobj()->mm_string_new(proc, oop_output)"
      }[typeName];
      if (!wrap) {
        Exception.throw("Unknown type `" + typeName + "'");
      }

      out.append(" ");          // indentation
      out.append(rtype.genType());
      out = out + ["output", "=", this.getName(), params, "\n",
                   " oop", "oop_output", "=", wrap + ";\n",
                   " proc->stack_push(oop_output);"];
    }

    return out.join(" ");
  }
  instance_method toString: fun() {
    var output = [];
    output.append(this.genFunSignature());
    this.getParams().each(fun(i, p) {
      output.append("\n  /* Argument[" + i.toString + "] */");
      output.append(this.genGetArg(i, p));
      output.append(this.genChkArg(p));
      output.append(this.genUnwrapArg(p));
    });
    output.append("\n  /* Call to the underlying function */");
    output.append(this.genFunCall());
    output.append("  return 0;");
    output.append("}");
    return output.join("\n");
  }
end
