meme central:memescript/compiler

requires io
where
  io         = central:stdlib/io

class Param
  fields: name, typeName, isPointer, isArray, isConst, isUnsigned,
    isOutput, isNullable, isUnknown;

  init new: fun() {
    @isPointer = false;
    @isArray = false;
    @isConst = false;
    @isUnsigned = false;
    @isOutput = false;
    @isNullable = false;
    @isUnknown = false;
  }
  instance_method setName: fun(name) { @name = name; }
  instance_method setTypeName: fun(typeName) { @typeName = typeName; }
  instance_method setIsArray: fun(isArray) { @isArray = isArray; }
  instance_method setIsPointer: fun(isPointer) { @isPointer = isPointer; }
  instance_method setIsConst: fun(isConst) { @isConst = isConst; }
  instance_method setIsUnsigned: fun(isUnsigned) { @isUnsigned = isUnsigned; }
  instance_method setIsOutput: fun(isOutput) { @isOutput = isOutput; }
  instance_method setIsNullable: fun(isNullable) { @isNullable = isNullable; }
  instance_method setIsUnknown: fun(isUnknown) { @isUnknown = isUnknown; }
  instance_method setAnnotations: fun(annotations) {
    annotations.each(fun(_, a) {
      if (a == "out") {
        this.setIsOutput(true);
      } elif (a == "null") {
        this.setIsNullable(true);
      }
    });
  }

  instance_method getName: fun() { return @name; }
  instance_method getTypeName: fun() { return @typeName; }
  instance_method getIsArray: fun() { return @isArray; }
  instance_method getIsPointer: fun() { return @isPointer; }
  instance_method getIsConst: fun() { return @isConst; }
  instance_method getIsUnsigned: fun() { return @isUnsigned; }
  instance_method getIsOutput: fun() { return @isOutput; }
  instance_method getIsNullable: fun() { return @isNullable; }
  instance_method getIsUnknown: fun() { return @isUnknown; }

  instance_method genType: fun() {
    var out = [];
    if (this.getIsConst()) { out.append("const"); }
    if (this.getIsUnsigned()) { out.append("unsigned"); }
    out.append(this.getTypeName());
    if (this.getIsPointer()) { out.append("*".times(this.getIsPointer())); }
    return out.join(" ");
  }
  instance_method toString: fun() {
    return [
      "       Name: " + @name.toString,
      "   TypeName: " + @typeName.toString,
      "    IsArray: " + @isArray.toString,
      "    IsConst: " + @isConst.toString,
      "  IsPointer: " + @isPointer.toString,
      " IsUnsigned: " + @isUnsigned.toString,
      "   IsOutput: " + @isOutput.toString,
      " IsNullable: " + @isNullable.toString,
      "  isUnknown: " + @isUnknown.toString
    ].join("\n");
  }
end

class Struct
  fields: name, fieldList;

  init new: fun(name) {
    @name = name;
    @fieldList = [];
  }
  instance_method newChild: fun() {
    var newField = Param.new();
    @fieldList.append(newField);
    return newField;
  }
  instance_method getName: fun() {
    return @name;
  }
  instance_method getFieldList: fun() {
    return @fieldList;
  }
  instance_method setName: fun(name) {
    @name = name;
  }
  instance_method toString: fun() {
    return "MEME_INSTANCE(" + @name + ", \"" + @name + "\")";
    // var structFields = @fieldList
    //   .map(fun(i) { return [" ", i.genType, i.getName].join(" ") + ";"; })
    //   .join("\n");
    // return ["struct", @name, "{\n", structFields, "\n}"].join(" ");
  }
end

class Fun
  fields: name, params, rtype;

  init new: fun(name) {
    @name = name;
    @params = [];
  }
  instance_method newChild: fun() {
    var param = Param.new();
    @params.append(param);
    return param;
  }
  instance_method newReturnType: fun() {
    var rtype = Param.new();
    @rtype = rtype;
    return rtype;
  }
  instance_method getName: fun() {
    return @name;
  }
  instance_method getParams: fun() {
    return @params;
  }
  instance_method getReturnType: fun() {
    return @rtype;
  }
  instance_method genFunSignature: fun() {
    return ["static", "int", "prim_" + this.getName(),
            "(Process* proc)", "{"].join(" ");
  }
  instance_method genGetArg: fun(i, arg) {
    return ["  oop", "oop_" + arg.getName(), "=",
            "proc->get_arg(" + i.toString() + ");"].join(" ");
  }
  instance_method getTypeNameFromParam: fun(param) {
    var typeName = param.getTypeName();
    if (param.getIsUnknown()) {
      return "";
    }
    if (typeName.substr(0, 7) == "struct ") {
      return "struct";
    }
    return typeName;
  }
  instance_method genChkArg: fun(module, arg) {
    var out = [];
    var typeName = module.getTypeNameFromParam(arg);
    var primeType = {
      "": "Integer",
      "int": "Integer",
      "long": "LongNum",
      "char": "String",
      "struct": "Object"
    }[typeName];
    if (!primeType) {
      Exception.throw("Unknown type `" + typeName + "'");
    }

    var vname = "oop_" + arg.getName();
    var errMessage = "Argument `" + arg.getName() + "' expected " + primeType;
    var validation =
      "!(proc->mmobj()->mm_object_vt(" + vname + ") == proc->vm()->get_prime(\"" + primeType + "\"))";
    if (arg.getIsNullable) {
      validation = "(" + vname + " != MM_NULL) && " + typeValidator;
      errMessage = errMessage + " or null";
    }

    out.append("  if (" + validation + ") {");
    out.append("    proc->raise(\"TypeError\", \"" + errMessage + "\");");
    out.append("  }");
    return out.join("\n");
  }
  instance_method genUnwrapArg: fun(module, arg) {
    var typeName = this.getTypeNameFromParam(arg);
    var type = arg.genType();
    var argName = "oop_" + arg.getName();
    var unwrap = {
      "": "untag_small_int(" + argName + ")",
      "int": "untag_small_int(" + argName + ")",
      "long": "proc->mmobj()->mm_longnum_get(proc, " + argName + ")",
      "char": "proc->mmobj()->mm_string_cstr(proc, " + argName + ")",
      "struct": "(" + type + ") ((oop *) " + argName + ")[2]"
    }[typeName];
    if (!unwrap) {
      Exception.throw("Unknown type `" + typeName + "'");
    }
    if (arg.getIsNullable()) {
      unwrap = "(" + argName + " == MM_NULL ? NULL : " + unwrap + ")";
    }
    var out = [" "];            // indentation
    out.append(type);
    return (out + ["prim_" + arg.getName(), "=", unwrap + ";"]).join(" ");
  }
  instance_method genFunCall: fun(module) {
    var paramNames = this.getParams().map(fun(p) { "prim_" + p.getName });
    var params = "(" + paramNames.join(", ") + ");\n\n";
    var rtype = this.getReturnType();
    var out = [];
    if (rtype) {
      var typeName = this.getTypeNameFromParam(rtype);
      if (typeName == "void") {
        out.append([" ", this.getName(), params].join(" "));
        out.append(" /* Push output to the stack */\n");
        out.append(" proc->stack_push(MM_NULL);\n");
      } else {
        var wrap = {
          "": "tag_small_int(output)",
          "int": "tag_small_int(output)",
          "char": "proc->mmobj()->mm_string_new(output)",
          "struct": "meme_instance(proc, meme_mapping, \"" + typeName + "\", output, &exc)"
        }[typeName];
        if (!wrap) {
          Exception.throw("Unknown type `" + typeName + "'");
        }
        out.append([" ", rtype.genType(), "output", "=", this.getName(), params].join(" "));
        out.append(" /* Push output to the stack */\n");
        if (typeName == "struct") {
          out.append(" int exc = 0;\n");
        }
        out.append(" oop oop_output = " + wrap + ";\n");
        out.append(" proc->stack_push(oop_output);\n");
      }
    }
    return out.join(" ");
  }
  instance_method gen: fun(module) {
    var output = [];
    output.append(this.genFunSignature());
    this.getParams().each(fun(i, p) {
      output.append("\n  /* Argument[" + i.toString + "] */");
      output.append(this.genGetArg(i, p));
      output.append(this.genChkArg(module, p));
      output.append(this.genUnwrapArg(module, p));
    });
    output.append("\n  /* Call to the underlying function */");
    output.append(this.genFunCall(module));
    output.append("  return 0;");
    output.append("}");
    return output.join("\n");
  }
end

class Typedef
  fields: name, type;

  init new: fun(name) {
    @name = name;
    @type = Param.new;
  }
  instance_method getName: fun() {
    return @name;
  }
  instance_method getType: fun() {
    return @type;
  }
end

class Module
  fields: name, includes, structs, typedefs, funs;

  init new: fun(name) {
    @name = name;
    @includes = [];
    @structs = [];
    @typedefs = {};
    @funs = [];
  }
  instance_method appendInclude: fun(include) {
    @includes.append(include);
  }
  instance_method appendStruct: fun(o) {
    @structs.append(o);
    return o;
  }
  instance_method appendTypedef: fun(o) {
    @typedefs[o.getName()] = o.getType();
    return o;
  }
  instance_method appendFun: fun(o) {
    @funs.append(o);
    return o;
  }

  instance_method getIncludes: fun() {
    return @includes;
  }

  instance_method getTypeNameFromParam: fun(param) {
    var typeName = param.getTypeName();
    if (param.getIsUnknown()) {
      var alias = @typedefs[typeName];
      if (alias) {
        return alias.getTypeName();
      }
    }
    if (typeName.substr(0, 7) == "struct ") {
      return "struct";
    }
    return typeName;
  }

  instance_method genMainFunction: fun(moduleName) {
    var output = ["void init_primitives(VM *vm) {"];
    @funs.each(fun(_, d) {
      var prim_name = moduleName + "_" + d.getName();
      output.append("  vm->register_primitive(\"" + prim_name + "\", prim_" + d.getName() + ");");
    });
    output.append("}");
    return output.join("\n");
  }
  instance_method toString: fun() {
    var output = [];
    output.append("#include <vm.hpp>");
    output.append("#include <bindgen.hpp>");
    output.append(@includes.map(fun(i) { "#include " + i.toString }).join("\n\n"));
    output.append("");
    output.append("static std::map<void*, oop> meme_mapping;\n");
    output.append("");
    output.append(@structs.map(fun(i) { i.toString }).join("\n"));
    output.append("");
    output.append(@funs.map(fun(i) { i.gen(this) }).join("\n\n"));
    output.append("");
    output.append(this.genMainFunction(@name));
    return output.join("\n");
  }
end
