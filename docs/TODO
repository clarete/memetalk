--
files in /doc should be commited separately. Their commits should not go
to master.
--

 TODO:
 -Goal: live reprogramming
   -write a tabbed editor + inspector + debugger. Compiler eval-ready
   -Allow patching live code (existing functions, classes, modules)
   -Dump modules sources to file again.


   -reify the instantiation of modules (use constructor instead of the specific python functions)
     -loading creates the CompiledModule and Module internally.
     -instantiating a module should be a message send to the Module.
     -reify message lookup
     -reify MessageNotUnderstood, maybe implement exceptions.
     -reify the definitions of the core objects in someway
      *even if it means creating a DSL for describing them.
     -> Make sure everything possible is reified in memetalk
     -loading of modules, compilation, etc. to memetalk
     *the only thing that should be here is execution,
      thus, implementing a different runtime should be easier


 -VM: Squeak approach:
   -write the VM in memetalk
   -translate it to C, and compile it.
   -GC


------
We are departing from the original plan for 3nd, which would be generated
from 2nd, originally. As I had to take a break of months, lots of things need
remebering and working out. So here is the new roadmap for 3nd:

-Re-engineer a python VM focusing on:

  -the organization of Objects, Behaviors Classes, and Compiled* classes,
   all prepared to suffer on-the-fly updates (ie, compilation during runtime
   should be able to easily patch those objects).

  -Figure out how to implmement linker, loader and compiler in memetalk,
   maybe without doing a python version first (maybe if we design a small
   language from where we translate to python and to memetalk and implement
   those things in that language? Or maybe translate from memetalk to python,
   we could write the compiler in memetalk)

  -compiler should be structured in a way which makes it easy to do eval()
   of code on the fly.

  -development tools: they should be the final result of 3nd: full interactive
   debugging and patching working.

So, the 3nd python VM should be really clean, without the boilerplate from
Compiler and loader/linker code which impregnated 2nd. We should also learn
more about the structuring of the objects and the core components (vm, loader,
linker, compiler) and bytecode format with debugging info.

With a clean VM, the boot.img file should have all the objects previously
observed that should be there: from modules core (behavior,object), std
(string,arrays,etc) and dev (compiler,loader,linker).


-- The approach: creating a compiler through translation --

# phase 1: bootstrapping #

Goal: work on the compiler, ometa translators, generating image files, and
establish a robust object organization for growing (this last one for phase 2)

Steps:

1) write the compiler in memetalk: a simple preditive recursive one.
   it should have eval() in mind.
2) write a pymeta translator from memetalk -> python
 --Now we can translate the compiler to python.

3) Design the object runtime structure (behaviors, meta objects, etc).
   everything we need to represent modules, module instances, classes, class
   instances, and patch them.

4) Feed the python compiler with the compiler's original memetalk source
 --Now we have the bytecode of the compiler for memetalk, which we can
   run on a vm.

With a simple VM and the bytecode for the compiler, we still cannot use the
memetalk compiled compiler to compile memetalk code. We need to bridge the gap
of the loading/bootstrap of the vm. The VM needs to read-in (not load, we
don't have a loader yet) the core/std/loader from an image file. However, we
don't have those objects yet.

For Object and ObjectBehavior, we need a way to describe them (which might
imply using the compiler above) and dump their pure objects.

For the loader (and, its dependency, std), we need a way to have an image of
the /instance/ of the module, already tied to the module object itself. Ie, we
need std and loader ready to be used as instance modules, since we don't want
to have the VM loading stuff (ie. instantiating modules and linking).

So, we need:

a) A way to describe Object and ObjectBehavior and compile them to pure objects
b) A way to dump an instantiated module (and its master module).

Perhaps making the compiler generate a normal .mmc, and using a custom python
script to create the module instances, and tie them with a dummy/default
Object and ObjectBheavior, dumping the resulting heap image.

result: Now we should be able to use the loader. Which means we can get the
compiler.mmc (generated by the python compiler) loaded into the VM, and use it
to compile source code. Also, the runtime objects should be ready to be easily
patched on the fly, which means:

   -methods can be added and removed from classes and modules
   -classes can be added and removed from modules
   -class properties can be changed (name, parent, fields)
   -module properties can be changed (name and parameters)
   -modules can be added and removed.

# phase 2: growing #

Goal: with the object organization in place for growing we now focus on
developing tools, in 3 parts:

1) Change the VM to accept interactive debugging.
2) Design the bytecode format to have file/line number information
3) Develop the gui tools: workspace, file editor, inspector and browser (in this order).
